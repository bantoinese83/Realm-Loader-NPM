<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realm Loader NPM - Browser Compatibility Test</title>
    <link rel="preconnect" href="https://fonts.cdnfonts.com">
    <link href="https://fonts.cdnfonts.com/css/thegoodmonolith" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #f0f0f0;
            font-family: "TheGoodMonolith", monospace;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .browser-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 30px;
            text-align: center;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-container {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .test-title {
            font-size: 16px;
            margin-bottom: 15px;
            color: #4ecdc4;
        }

        .animation-container {
            position: relative;
            width: 200px;
            height: 200px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-status {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-pass {
            background: #4caf50;
            color: white;
        }

        .status-fail {
            background: #f44336;
            color: white;
        }

        .status-pending {
            background: #ff9800;
            color: white;
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        button {
            padding: 10px 20px;
            margin: 0 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #f0f0f0;
            font-family: "TheGoodMonolith", monospace;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .performance-metrics {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .error-log {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>REALM LOADER NPM - BROWSER COMPATIBILITY TEST</h1>
        <p>Testing all animations across different browsers and devices</p>
        <p style="color: #4CAF50; font-size: 14px;">âœ¨ Center dots removed for cleaner look!</p>
    </div>

    <div class="browser-info">
        <h3>Browser Information</h3>
        <p id="browser-details">Detecting browser...</p>
        <p id="canvas-support">Canvas Support: <span id="canvas-status">Checking...</span></p>
        <p id="requestanimationframe-support">RequestAnimationFrame: <span id="raf-status">Checking...</span></p>
    </div>

    <div class="test-grid" id="test-grid">
        <!-- Test containers will be generated dynamically -->
    </div>

    <div class="controls">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="stopAllTests()">Stop All Tests</button>
        <button onclick="testPerformance()">Performance Test</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div class="performance-metrics" id="performance-metrics" style="display: none;">
        <h3>Performance Metrics</h3>
        <div id="metrics-content"></div>
    </div>

    <div class="error-log" id="error-log" style="display: none;">
        <h4>Error Log</h4>
        <div id="error-content"></div>
    </div>

    <script type="module">
        // Import the package (this would be the actual import in production)
        // import { CircleAnimations } from './dist/index.esm.js'
        
        // For testing, we'll simulate the package functionality
        class TestCircleAnimations {
            constructor(container, animation, config = {}) {
                this.container = container
                this.animation = animation
                this.config = config
                this.canvas = null
                this.ctx = null
                this.animationId = null
                this.time = 0
                this.isRunning = false
                this.startTime = null
                this.frameCount = 0
                
                this.init()
            }
            
            init() {
                try {
                    this.canvas = document.createElement('canvas')
                    this.canvas.width = 180
                    this.canvas.height = 180
                    this.canvas.style.position = 'absolute'
                    this.canvas.style.left = '0'
                    this.canvas.style.top = '0'
                    this.canvas.style.pointerEvents = 'none'
                    
                    this.ctx = this.canvas.getContext('2d')
                    if (!this.ctx) {
                        throw new Error('Canvas 2D context not supported')
                    }
                    
                    this.container.appendChild(this.canvas)
                    return true
                } catch (error) {
                    this.logError(`Failed to initialize ${this.animation}: ${error.message}`)
                    return false
                }
            }
            
            start() {
                if (!this.ctx) return false
                
                try {
                    this.isRunning = true
                    this.startTime = performance.now()
                    this.frameCount = 0
                    this.animate()
                    return true
                } catch (error) {
                    this.logError(`Failed to start ${this.animation}: ${error.message}`)
                    return false
                }
            }
            
            stop() {
                this.isRunning = false
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId)
                    this.animationId = null
                }
            }
            
            destroy() {
                this.stop()
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas)
                }
            }
            
            animate = () => {
                if (!this.isRunning) return
                
                try {
                    this.frameCount++
                    this.time += 0.016
                    
                    this.ctx.clearRect(0, 0, 180, 180)
                    this.draw()
                    
                    this.animationId = requestAnimationFrame(this.animate)
                } catch (error) {
                    this.logError(`Animation error in ${this.animation}: ${error.message}`)
                    this.stop()
                }
            }
            
            draw() {
                const centerX = 90
                const centerY = 90
                
                // Simple demo drawing based on animation type
                this.ctx.beginPath()
                this.ctx.arc(centerX, centerY, 3, 0, Math.PI * 2)
                this.ctx.fillStyle = this.config.color || '#ffffff'
                this.ctx.fill()
                
                // Animation-specific drawing
                switch (this.animation) {
                    case 'radial-pulse':
                        this.drawRadialPulse(centerX, centerY)
                        break
                    case 'orbital-pulse':
                        this.drawOrbitalPulse(centerX, centerY)
                        break
                    case 'pendulum-wave':
                        this.drawPendulumWave(centerX, centerY)
                        break
                    case 'pulse-wave':
                        this.drawPulseWave(centerX, centerY)
                        break
                    case 'concentric-rings':
                        this.drawConcentricRings(centerX, centerY)
                        break
                    case 'sequential-pulse':
                        this.drawSequentialPulse(centerX, centerY)
                        break
                    case 'oscillating-dots':
                        this.drawOscillatingDots(centerX, centerY)
                        break
                    case 'pulsing-grid':
                        this.drawPulsingGrid(centerX, centerY)
                        break
                    case 'spiral-galaxy':
                        this.drawSpiralGalaxy(centerX, centerY)
                        break
                }
            }
            
            drawRadialPulse(centerX, centerY) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + this.time
                    const radius = 30 + Math.sin(this.time * 2 + i) * 10
                    const x = centerX + Math.cos(angle) * radius
                    const y = centerY + Math.sin(angle) * radius
                    
                    this.ctx.beginPath()
                    this.ctx.arc(x, y, 2, 0, Math.PI * 2)
                    this.ctx.fillStyle = '#ff6b6b'
                    this.ctx.fill()
                }
            }
            
            drawOrbitalPulse(centerX, centerY) {
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = 20 + ring * 15
                    for (let i = 0; i < 6 + ring * 2; i++) {
                        const angle = (i / (6 + ring * 2)) * Math.PI * 2 + this.time * (0.5 + ring * 0.2)
                        const x = centerX + Math.cos(angle) * ringRadius
                        const y = centerY + Math.sin(angle) * ringRadius
                        
                        this.ctx.beginPath()
                        this.ctx.arc(x, y, 1.5, 0, Math.PI * 2)
                        this.ctx.fillStyle = '#4ecdc4'
                        this.ctx.fill()
                    }
                }
            }
            
            drawPendulumWave(centerX, centerY) {
                for (let i = 0; i < 8; i++) {
                    const x = centerX - 60 + i * 15
                    const y = centerY - 40
                    const bobY = y + 40 + Math.sin(this.time * 2 + i * 0.5) * 20
                    
                    this.ctx.beginPath()
                    this.ctx.moveTo(x, y)
                    this.ctx.lineTo(x, bobY)
                    this.ctx.strokeStyle = '#45b7d1'
                    this.ctx.lineWidth = 1
                    this.ctx.stroke()
                    
                    this.ctx.beginPath()
                    this.ctx.arc(x, bobY, 3, 0, Math.PI * 2)
                    this.ctx.fillStyle = '#45b7d1'
                    this.ctx.fill()
                }
            }
            
            drawPulseWave(centerX, centerY) {
                for (let ring = 0; ring < 4; ring++) {
                    const ringRadius = 15 + ring * 12
                    for (let i = 0; i < 8 + ring * 2; i++) {
                        const angle = (i / (8 + ring * 2)) * Math.PI * 2
                        const pulse = Math.sin(this.time * 2 + ring * 0.5) * 3
                        const x = centerX + Math.cos(angle) * (ringRadius + pulse)
                        const y = centerY + Math.sin(angle) * (ringRadius + pulse)
                        
                        this.ctx.beginPath()
                        this.ctx.arc(x, y, 1.5, 0, Math.PI * 2)
                        this.ctx.fillStyle = '#96ceb4'
                        this.ctx.fill()
                    }
                }
            }
            
            drawConcentricRings(centerX, centerY) {
                for (let ring = 0; ring < 4; ring++) {
                    const ringRadius = 20 + ring * 15
                    for (let i = 0; i < 6 + ring * 3; i++) {
                        const angle = (i / (6 + ring * 3)) * Math.PI * 2 + this.time * (0.3 + ring * 0.1)
                        const x = centerX + Math.cos(angle) * ringRadius
                        const y = centerY + Math.sin(angle) * ringRadius
                        
                        this.ctx.beginPath()
                        this.ctx.arc(x, y, 2, 0, Math.PI * 2)
                        this.ctx.fillStyle = '#feca57'
                        this.ctx.fill()
                    }
                }
            }
            
            drawSequentialPulse(centerX, centerY) {
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2
                    const pulse = Math.sin(this.time * 2 + i * 0.5) * 5
                    const x = centerX + Math.cos(angle) * (40 + pulse)
                    const y = centerY + Math.sin(angle) * (40 + pulse)
                    
                    this.ctx.beginPath()
                    this.ctx.arc(x, y, 2, 0, Math.PI * 2)
                    this.ctx.fillStyle = '#ff9ff3'
                    this.ctx.fill()
                }
            }
            
            drawOscillatingDots(centerX, centerY) {
                for (let row = 0; row < 4; row++) {
                    const y = centerY - 30 + row * 20
                    for (let i = 0; i < 12; i++) {
                        const x = centerX - 60 + i * 10
                        const offset = Math.sin(this.time * 2 + i * 0.3 + row * 0.5) * 8
                        
                        this.ctx.beginPath()
                        this.ctx.arc(x, y + offset, 1.5, 0, Math.PI * 2)
                        this.ctx.fillStyle = '#54a0ff'
                        this.ctx.fill()
                    }
                }
            }
            
            drawPulsingGrid(centerX, centerY) {
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        const x = centerX - 40 + col * 20
                        const y = centerY - 40 + row * 20
                        const pulse = Math.sin(this.time * 2 + row + col) * 3
                        
                        this.ctx.beginPath()
                        this.ctx.arc(x, y, 1.5 + pulse, 0, Math.PI * 2)
                        this.ctx.fillStyle = '#5f27cd'
                        this.ctx.fill()
                    }
                }
            }
            
            drawSpiralGalaxy(centerX, centerY) {
                for (let i = 0; i < 50; i++) {
                    const angle = this.time * 0.5 + i * 0.2
                    const radius = 10 + i * 2
                    const x = centerX + Math.cos(angle) * radius
                    const y = centerY + Math.sin(angle) * radius
                    
                    this.ctx.beginPath()
                    this.ctx.arc(x, y, 1, 0, Math.PI * 2)
                    this.ctx.fillStyle = '#00d2d3'
                    this.ctx.fill()
                }
            }
            
            logError(message) {
                const errorLog = document.getElementById('error-content')
                if (errorLog) {
                    errorLog.innerHTML += `<div>${new Date().toLocaleTimeString()}: ${message}</div>`
                    document.getElementById('error-log').style.display = 'block'
                }
                console.error(message)
            }
            
            getPerformanceMetrics() {
                if (!this.startTime) return null
                
                const now = performance.now()
                const duration = now - this.startTime
                const fps = this.frameCount / (duration / 1000)
                
                return {
                    duration: duration,
                    frameCount: this.frameCount,
                    fps: fps,
                    averageFrameTime: duration / this.frameCount
                }
            }
        }
        
        // Test configuration
        const animationTypes = [
            'radial-pulse', 'orbital-pulse', 'pendulum-wave', 'pulse-wave',
            'concentric-rings', 'sequential-pulse', 'oscillating-dots',
            'pulsing-grid', 'spiral-galaxy'
        ]
        
        const testAnimations = {}
        const testResults = {}
        
        // Initialize browser detection
        function detectBrowser() {
            const ua = navigator.userAgent
            let browser = 'Unknown'
            let version = 'Unknown'
            
            if (ua.includes('Chrome')) {
                browser = 'Chrome'
                version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Unknown'
            } else if (ua.includes('Firefox')) {
                browser = 'Firefox'
                version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Unknown'
            } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                browser = 'Safari'
                version = ua.match(/Version\/(\d+)/)?.[1] || 'Unknown'
            } else if (ua.includes('Edge')) {
                browser = 'Edge'
                version = ua.match(/Edge\/(\d+)/)?.[1] || 'Unknown'
            }
            
            document.getElementById('browser-details').textContent = `${browser} ${version}`
        }
        
        // Check browser capabilities
        function checkCapabilities() {
            const canvas = document.createElement('canvas')
            const canvasSupported = !!(canvas.getContext && canvas.getContext('2d'))
            const rafSupported = !!(window.requestAnimationFrame)
            
            document.getElementById('canvas-status').textContent = canvasSupported ? 'Supported' : 'Not Supported'
            document.getElementById('canvas-status').className = canvasSupported ? 'status-pass' : 'status-fail'
            
            document.getElementById('raf-status').textContent = rafSupported ? 'Supported' : 'Not Supported'
            document.getElementById('raf-status').className = rafSupported ? 'status-pass' : 'status-fail'
            
            return canvasSupported && rafSupported
        }
        
        // Create test containers
        function createTestContainers() {
            const testGrid = document.getElementById('test-grid')
            
            animationTypes.forEach((type, index) => {
                const testContainer = document.createElement('div')
                testContainer.className = 'test-container'
                testContainer.innerHTML = `
                    <div class="test-title">${type.replace('-', ' ').toUpperCase()}</div>
                    <div class="animation-container" id="test-${type}"></div>
                    <div class="test-status status-pending" id="status-${type}">PENDING</div>
                `
                testGrid.appendChild(testContainer)
            })
        }
        
        // Run individual test
        function runTest(animationType) {
            const container = document.getElementById(`test-${animationType}`)
            const statusElement = document.getElementById(`status-${animationType}`)
            
            try {
                const animation = new TestCircleAnimations(container, animationType, {
                    color: '#ffffff',
                    speed: 1
                })
                
                if (animation.start()) {
                    testAnimations[animationType] = animation
                    testResults[animationType] = 'PASS'
                    statusElement.textContent = 'PASS'
                    statusElement.className = 'test-status status-pass'
                    return true
                } else {
                    testResults[animationType] = 'FAIL'
                    statusElement.textContent = 'FAIL'
                    statusElement.className = 'test-status status-fail'
                    return false
                }
            } catch (error) {
                testResults[animationType] = 'FAIL'
                statusElement.textContent = 'FAIL'
                statusElement.className = 'test-status status-fail'
                console.error(`Test failed for ${animationType}:`, error)
                return false
            }
        }
        
        // Run all tests
        function runAllTests() {
            console.log('Starting browser compatibility tests...')
            
            if (!checkCapabilities()) {
                alert('Browser does not support required features (Canvas 2D or RequestAnimationFrame)')
                return
            }
            
            let passedTests = 0
            animationTypes.forEach((type) => {
                if (runTest(type)) {
                    passedTests++
                }
            })
            
            console.log(`Tests completed: ${passedTests}/${animationTypes.length} passed`)
        }
        
        // Stop all tests
        function stopAllTests() {
            Object.values(testAnimations).forEach(animation => {
                animation.stop()
            })
            console.log('All tests stopped')
        }
        
        // Performance test
        function testPerformance() {
            const metricsDiv = document.getElementById('performance-metrics')
            const metricsContent = document.getElementById('metrics-content')
            
            metricsDiv.style.display = 'block'
            metricsContent.innerHTML = '<p>Running performance test for 5 seconds...</p>'
            
            setTimeout(() => {
                const metrics = Object.entries(testAnimations).map(([type, animation]) => {
                    const perf = animation.getPerformanceMetrics()
                    return { type, ...perf }
                })
                
                metricsContent.innerHTML = metrics.map(metric => `
                    <div class="metric">
                        <span>${metric.type}</span>
                        <span>FPS: ${metric.fps ? metric.fps.toFixed(1) : 'N/A'}</span>
                        <span>Frames: ${metric.frameCount || 0}</span>
                        <span>Avg Frame: ${metric.averageFrameTime ? metric.averageFrameTime.toFixed(2) : 'N/A'}ms</span>
                    </div>
                `).join('')
            }, 5000)
        }
        
        // Clear results
        function clearResults() {
            Object.values(testAnimations).forEach(animation => {
                animation.destroy()
            })
            
            animationTypes.forEach(type => {
                const statusElement = document.getElementById(`status-${type}`)
                statusElement.textContent = 'PENDING'
                statusElement.className = 'test-status status-pending'
            })
            
            document.getElementById('error-log').style.display = 'none'
            document.getElementById('performance-metrics').style.display = 'none'
            
            testAnimations = {}
            testResults = {}
        }
        
        // Global functions
        window.runAllTests = runAllTests
        window.stopAllTests = stopAllTests
        window.testPerformance = testPerformance
        window.clearResults = clearResults
        
        // Initialize on load
        window.addEventListener('load', () => {
            detectBrowser()
            createTestContainers()
            console.log('Browser compatibility test suite loaded')
        })
    </script>
</body>
</html>
